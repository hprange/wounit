<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>WOUnit - Test framework for WebObjects</title>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/all-min.js"></script>
		<link href="css/all-min.css" rel="stylesheet" type="text/css" />
		<script type="text/javascript">
			var _gaq = _gaq || [];
			_gaq.push(['_setAccount', 'UA-22475266-2']);
			_gaq.push(['_trackPageview']);
			(function() {
				var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
				ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
				var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			})();
		</script>
	</head>
	<body>
		<a href="http://github.com/hprange/wounit"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>
		<div id="container">
			<div class="download">
				<a href="http://github.com/hprange/wounit/zipball/wounit-1.1.1">
					<img border="0" width="90" src="images/zip.png" alt="" /></a>
				<a href="https://github.com/downloads/hprange/wounit/wounit-1.1.1.jar">
					<img border="0" width="90" src="images/jar.png" alt="" /></a>
			</div>
			<h1><a href="index.html"><img border="0" src="images/wounit.png" alt="" /></a></h1>
			<div class="description">
				The WOUnit framework contains a set of utilities for testing WebObjects 
				applications using JUnit 4.7 or later capabilities.
			</div>
			<h2>WOUnit Basics</h2>
			<p>
				The WOUnit framework provides implementations of the MethodRule interface defined by JUnit. You don't have to know the internals of the MethodRule in order to write tests with WOUnit. It is enough to know that you need to annotate a public field in your test class with the <code>@Rule</code> (lines 8 and 9). Annotating the MockEditingContext field is sufficient to ensure that the editing context will be initialized before and disposed after each test case has been executed.
			</p>
			<p>
				<pre class="brush: java; toolbar: false; highlight: [1,8,9,11,12,18];">
import static com.wounit.matchers.EOAssert.*;
import com.wounit.rules.MockEditingContext;
import com.wounit.annotations.UnderTest;
import org.junit.Rule;
import org.junit.Test;

public class FooTest {
	@Rule
	public MockEditingContext ec = new MockEditingContext("MyModel");
	
	@UnderTest
	private Foo foo;
	
	@Test
	public void cantSaveFooWithNullProperty() {
		foo.setProperty(null);
		
		confirm(foo, cannotBeSaved());
	}
}</pre>
			</p>
			<p>
				From version 1.1 of WOUnit framework, the <code>@UnderTest</code> and <code>@Dummy</code> annotations were added to simplify the creation of enterprise objects. Fields annotated with one of those annotations are automatically populated with an inserted instance of the expected enterprise object type (lines 11 and 12).
			</p>
			<p>
				Another feature of the WOUnit framework is a collection of matchers to facilitate the verification of conditions related to enterprise objects and editing contexts. If you static import the <code>EOAssert</code> methods then you'll be able to write more readable assertions (lines 1 and 18).
			</p>
			<h2>Unit Test with MockEditingContext</h2>
			<p>
				The MockEditingContext class provides means for fast in-memory testing of EOEnterpriseObjects. This class is useful for unit testing because it allows the creation of dummy objects that don't participate in the augmented transaction process. You can use it to validate the behavior of a unit in isolation.
			</p>
			<p>
				You can pass an array of model names as the parameter of the MockEditingContext, and it will try to load the models automatically.
			</p>
			<p>
				<pre class="brush: java; toolbar: false;">
public class TestMyModel {
	@Rule
	public MockEditingContext ec = new MockEditingContext("MyModel");
	...
}</pre>
			</p>
			<p>
				You can create real objects in the same way you are used to do in your application (line 3). Then you can create dummy objects to interact with them (line 5). The MockEditingContext does not track changes on dummy objects.
			</p>
			<p>
				<pre class="brush: java; toolbar: false; highlight: [3,5];">
@Test
public void testingFooLogic() {
	Foo foo = Foo.createFoo(ec);
	
	Bar dummyBar = ec.createSavedObject(Bar.class);
	
	// Do something with foo using the dummy object...
}</pre>
			</p>
			<p>
				You can also create and insert a dummy object. Very useful if you need to 
				decorate or spy saved objects.
			</p>
			<p>
				<pre class="brush: java; toolbar: false;">
@Test
public void testingAnotherFooLogic() {
	Foo foo = Foo.createFoo(ec);
	
	// Decorate or spy a dummy object before inserting
	Bar dummyBar = spy(new Bar());
	
	ec.insertSavedObject(dummyBar);
	
	// Do something with foo using the dummy object...
}</pre>
			</p>
			<h2>Integration Test with TemporaryEditingContext</h2>
			<p>
				The TemporaryEditingContext class provides means to create temporary 
				enterprise objects for unit testing. It is an editing context configured with 
				the memory adaptor settings that is guaranteed to be reset when the test
				method finishes (whether it passes or fails).
			</p>
			<p>This class is useful for integration testing because it mimics the internal 
				behavior of the ERXEC. Every EOEnterpriseObject inserted in the 
				TemporaryEditingContext behaves as a real EO. This kind of feature is useful to 
				validate the behavior of a group of EOs.
				<pre class="brush: java; toolbar: false;">
public class MyModelTest {
	@Rule
	public TemporaryEditingContext ec = 
			new TemporaryEditingContext("MyModel");
	
	@Test
	public void testingMyModelLogic() throws Exception {
		Foo foo = Foo.createFoo(ec);
		
		Bar bar = Bar.createBar(ec);
		
		// Do something with foo and bar...
		
		// Verify a condition of foo and bar...
	}
}</pre>
			</p>
			<h2><code>@Dummy</code> and <code>@UnderTest</code> Annotations</h2>
			<p>
				Creating the object under test and related dummy objects for each test case can
				be a very monotonous task.
				<pre class="brush: java; toolbar: false;">
public class FooTest {
	@Test
	public void testOneLogic() throws Exception {
		Foo foo = Foo.createFoo(ec);
		
		Bar dummyBar = ec.createSavedObject(Bar.class);
		
		// Do something with foo...
		
		// Verify a condition of foo or bar...
	}
	
	@Test
	public void testAnotherLogic() throws Exception {
		Foo foo = Foo.createFoo(ec);
		
		Bar dummyBar = ec.createSavedObject(Bar.class);
		
		// Do something else with foo...
		
		// Verify another condition of foo or bar...
	}
}</pre>
			</p>
				JUnit provides the <code>@Before</code> annotation to alleviate
				the repetitive task of creating test fixtures.
				<pre class="brush: java; toolbar: false;">
public class FooTest {
	private Foo foo;
	private Bar dummyBar;
	
	@Before
	public void setup() {
		foo = Foo.createFoo(ec);
		dummyBar = ec.createSavedObject(Bar.class);
	}
	
	@Test
	public void testOneLogic() throws Exception {
		// Do something with foo...
		
		// Verify a condition of foo or bar...
	}
	
	@Test
	public void testAnotherLogic() throws Exception {
		// Do something else with foo...
		
		// Verify another condition of foo or bar...
	}
}</pre>
			</p>
			<p>
				However, even that solution requires a bit of boilerplate code.
				The <code>@UnderTest</code> and <code>@Dummy</code> annotations were developed
				to simplify the creation of enterprise objects.
				<pre class="brush: java; toolbar: false;">
public class FooTest {
	@UnderTest
	private Foo foo;
	
	@Dummy
	private Bar dummyBar;
	
	@Test
	public void testOneLogic() throws Exception {
		// Do something with foo...
		
		// Verify a condition of foo or bar...
	}
	
	@Test
	public void testAnotherLogic() throws Exception {
		// Do something else with foo...
		
		// Verify another condition of foo or bar...
	}
}</pre>
			</p>
			<p>
				The <code>@UnderTest</code> annotation can be used to create real enterprise objects and insert them into the editing context rule. Usually, unit tests will have only one field annotated with <code>@UnderTest</code> and the need for more than one field annotated can be considered a test smell. This annotation can be used with both <code>MockEditingContext</code> or <code>TemporaryEditingContext</code> rules.
			</p>
			<p>
				The <code>@Dummy</code> annotation can be used to create saved enterprise objects and insert them into the editing context rule. You can have as many fields annotated with <code>@Dummy</code> as required to test the object under test in isolation. This annotation only works with the <code>MockEditingContext</code> rule.
			</p>
			<h2>Assertion with EOAssert</h2>
			<p>
				The <code>EOAssert</code> class is the entry point for writing assertions to WebObjects related unit tests. This class provides static methods to check conditions against enterprise objects and editing contexts.
				<h3>Enterprise Object State</h3>
				<pre class="brush: java; toolbar: false;">
// Checks whether the eo has been saved and has no pending changes
confirm(eo, hasBeenSaved());

// Checks whether the eo has not been saved
confirm(eo, hasNotBeenSaved());

// Checks whether the eo has been deleted
confirm(eo, hasBeenDeleted());

// Checks whether the eo has not been deleted
confirm(eo, hasNotBeenDeleted());</pre>
				<h3>Enterprise Object Validity</h3>
				<pre class="brush: java; toolbar: false;">
// Checks whether the eo can be saved
confirm(eo, canBeSaved());

// Checks whether the eo cannot be saved
confirm(eo, cannotBeSaved());

// Safer check whether eo cannot be saved
confirm(eo, cannotBeSavedBecause("The foo property can't be null"));

// Checks whether the eo can be deleted
confirm(eo, canBeDeleted());

// Checks whether the eo cannot be deleted
confirm(eo, cannotBeDeleted());

// Safer check whether eo cannot be deleted
confirm(eo, cannotBeDeletedBecause("It is a required object"));</pre>
				<h3>Editing Context Save Changes</h3>
				<pre class="brush: java; toolbar: false;">
// Checks whether the editing context save changes successfully
confirm(editingContext, saveChanges());

// Checks whether the editing context does not save changes
confirm(editingContext, doNotSaveChanges());

// Safer check whether the editing context does not save changes
confirm(editingContext, doNotSaveChangesBecause(
		"The bar property of Foo cannot be null"));</pre>
			</p>
			<div class="footer">
				get the source code on GitHub : <a href="http://github.com/hprange/wounit">hprange/wounit</a>
			</div>
		</div>
		<script type="text/javascript">
			SyntaxHighlighter.all();
		</script>
	</body>
</html>
